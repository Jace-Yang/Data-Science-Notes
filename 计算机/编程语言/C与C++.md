## 基本语法

**Const**

- 被 const 修饰（在 const 后面）的值不可改变
- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为指向常量的指针（const char* a）和自身是常量的指针（常量指针，char* const a）;
- 修饰引用，指向常量的引用（const char& a），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
- 修饰成员函数，说明该成员函数内不能修改成员变量。 

**static**

- 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
- 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为static。
- 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
- 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在     static 函数内不能访问非静态成员。

**inline 内联函数**

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch等复杂操作的内联函数；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

**friend 友元类和友元函数**

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制

**using 指示**

using 指示使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了

**:: 范围解析运算符**

- 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

**引用**

**左值引用**

常规引用，一般表示对象的身份。

**右值引用**

右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

**成员初始化列表**

- 更高效：少了一次调用默认构造函数的过程。

- 有些场合必须要用初始化列表： 

- 1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
  2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
  3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化

**面向对象**

面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。面向对象三大特征 —— 封装、继承、多态

**封装**

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。

- public 成员：可以被任意实体访问
- protected 成员：只允许被子类及本类的成员函数访问
- private     成员：只允许被本类的成员函数、友元类或友元函数访问

**继承**

- 基类（父类）——> 派生类（子类）

**多态**

- 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。

- 多态是以封装和继承为基础的。

- C++ 多态分类及实现： 

- 1. 重载多态（Ad-hoc      Polymorphism，编译期）：函数重载、运算符重载
  2. 子类型多态（Subtype      Polymorphism，运行期）：虚函数
  3. 参数多态性（Parametric      Polymorphism，编译期）：类模板、函数模板
  4. 强制多态（Coercion      Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

## Makefile

1.基础

一个工程中的源文件不计数，其按**类型、功能、模块**分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作

通常一个项目的执行分成四个部分

**预处理：**写好的高级语言的程序文本比如hello.c,预处理器根据#开头的命令，修改原始的程序，如#include<stdio.h>,将把系统中的头文件插入到程序文本中，通常是以.i结尾的文件

**编译阶段：**编译器将hello.i文件翻译成文本文件*hello.s,这个是汇编语言程序。高级语言是源程序。所以注意概念之间的区别。汇编语言程序干嘛？每条语句都以标准的文本格式确切描述一条低级机器语言指令。*不同的高级语言翻译的汇编语言相同

**汇编阶段：**汇编器将hello.s翻译成机器语言指令。把这些指令打包成可重定位目标程序，即.o文件。hello.o是一个二进制文件，它的字节码是机器语言指令，不再是字符。前面两个阶段都还有字符

**链接阶段：**比如hello程序调用printf程序，它是每个C编译器都会提供的标准库C的函数。这个函数存在于一个名叫printf.o的单独编译好的目标文件中，这个文件将以某种方式合并到hello.o中。链接器就负责这种合并。得到的是可执行目标文件

2.makefile组成

target    - 目标文件, 可以是 Object File, 也可以是可执行文件

prerequisites - 生成 target 所需要的文件或者目标

command    - make需要执行的命令 (任意的shell命令), Makefile中的命令必须以 [tab] 开头

语法如下所示：

target ... : prerequisites ...
   command
   …

 